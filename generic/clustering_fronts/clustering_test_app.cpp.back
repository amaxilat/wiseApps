/*
 * Fronts Applications using Neighbor Discovery
 */
//#define DB -1


#define DB_CLR
#include "external_interface/external_interface_testing.h"
#include "algorithms/neighbor_discovery/echo.h"
#include "algorithms/cluster/fronts/fronts_core.h"
#include "algorithms/cluster/modules/chd/attr_chd.h"
#include "algorithms/cluster/modules/it/fronts_it.h"
#include "algorithms/cluster/modules/jd/bfs_jd.h"
//#include "radio/reliable/reliableradio.h"

#include "util/wisebed_node_api/virtual_extended_txradio.h"

#ifdef SHAWN
#include "external_interface/shawn/shawn_testbedservice_uart.h"
#endif


#define VISUALIZER
#define ENABLE_UART_CL
#define FAILURES_PERCENTAGE 30

typedef wiselib::OSMODEL Os;
typedef Os::TxRadio Radio;
typedef wiselib::VirtualExtendedTxRadioModel<Os, Os::TxRadio, Os::Uart> VRadio;

//typedef wiselib::ReliableRadio<Os, Radio, Os::Timer, Os::Debug> RRadio;

typedef wiselib::Echo<Os, VRadio, Os::Timer, Os::Debug> nb_t;

typedef Os::Radio::node_id_t node_id_t;
typedef Os::Radio::block_data_t block_data_t;

typedef wiselib::AtributeClusterHeadDecision<Os, VRadio> CHD_t;
typedef wiselib::BfsJoinDecision<Os, VRadio> JD_t;
typedef wiselib::FrontsIterator<Os, VRadio> IT_t;
typedef wiselib::FrontsCore<Os, VRadio, CHD_t, JD_t, IT_t> clustering_algo_t;

typedef Os::Uart::size_t uart_size_t;

class ClusteringFronts {
public:

    void init(Os::AppMainParameter& value) {


        radio_ = &wiselib::FacetProvider<Os, Os::TxRadio>::get_facet(value);
        timer_ = &wiselib::FacetProvider<Os, Os::Timer>::get_facet(value);
        debug_ = &wiselib::FacetProvider<Os, Os::Debug>::get_facet(value);
        clock_ = &wiselib::FacetProvider<Os, Os::Clock>::get_facet(value);
        position_ = &wiselib::FacetProvider<Os, Os::Position>::get_facet(value);
#ifdef ENABLE_UART_CL
        uart_ = &wiselib::FacetProvider<Os, Os::Uart>::get_facet(value);
#endif
        rand_ = &wiselib::FacetProvider<Os, Os::Rand>::get_facet(value);


        virtual_radio_.init(*radio_, *uart_, *debug_);


        /*
                TxPower power;
                power.set_dB(DB);
                radio_->set_power(power);
         */
//urn:wisebed:uzl1:0x1c72,urn:wisebed:uzl1:0xf851,urn:wisebed:uzl1:0xcff1,urn:wisebed:uzl1:0x5980,urn:wisebed:uzl1:0x1721,urn:wisebed:uzl1:0x96f0
if (
	(radio_->id()==408)||
	(radio_->id()==409)||
	(radio_->id()==410)||
	(radio_->id()==411)||
	(radio_->id()==412)||
	(radio_->id()==413)||
	(radio_->id()==0x1c72)||
	(radio_->id()==0xf851)||
	(radio_->id()==0xcff1)||
	(radio_->id()==0x5980)||
	(radio_->id()==0x1721)||
	(radio_->id()==0x96f0)
){

}
else {
        Os::TxRadio::TxPower power;
        power.set_dB(-12);
        radio_->set_power(power);
}
        //        radio_->set_channel(12);


//        virtual_radio_.enable_radio();
//        radio_->enable_radio();




#ifdef ENABLE_UART_CL
        //uart_->reg_read_callback<ClusteringFronts, &ClusteringFronts::handle_uart_msg > (this);
        //uart_->enable_serial_comm();
#endif

#ifdef SHAWN
        if (radio_->id() != 0) {
            debug_->debug("Node %d received enable from uart %d\n", radio_->id(), 6);

            neighbor_discovery.set_beacon_period(1000);
            neighbor_discovery.set_timeout_perdio(3000);


            counter = 0;


            neighbor_discovery.enable();
            //        print periodically the neighborhood list
            timer_->set_timer<ClusteringFronts,
                    &ClusteringFronts::start > (20000, this, 0);

            clustering_algo_.enable();
        }

#endif
        timer_->set_timer<ClusteringFronts,
                &ClusteringFronts::start > (2000, this, 0);
    }

    // --------------------------------------------------------------------

    void start(void*) {

if (
        (radio_->id()==408)||
        (radio_->id()==409)||
        (radio_->id()==410)||
        (radio_->id()==411)||
        (radio_->id()==412)||
        (radio_->id()==413)||
        (radio_->id()==0x1c72)||
        (radio_->id()==0xf851)||
        (radio_->id()==0xcff1)||
        (radio_->id()==0x5980)||
        (radio_->id()==0x1721)||
        (radio_->id()==0x96f0)
){
       neighbor_discovery.init(virtual_radio_, *clock_, *timer_, *debug_, 1000, 9000, 160,200);
}
else {
       neighbor_discovery.init(virtual_radio_, *clock_, *timer_, *debug_, 1000, 9000, 110, 125);
}
        // set the HeadDecision Module
        clustering_algo_.set_cluster_head_decision(CHD_);
        // set the JoinDecision Module
        clustering_algo_.set_join_decision(JD_);
        // set the Iterator Module
        clustering_algo_.set_iterator(IT_);
        clustering_algo_.init(virtual_radio_, *timer_, *debug_, *rand_, neighbor_discovery);
        clustering_algo_.set_maxhops(1);
        debug_->debug("ON", radio_->id());
        neighbor_discovery.enable();
        clustering_algo_.enable(40);
        disabled_ = false;
#ifdef VISUALIZER
        neighbor_discovery.register_debug_callback(0);
        clustering_algo_.register_debug_callback();
#endif


#ifdef SHAWN
        if (counter == 2) {

            if (radio_->id() == 0x1) {
                uint8_t message[2];
                message[0] = radio_->id() % 256;
                message[1] = radio_->id() / 256;
            }
        }
        counter++;
        /*
        if (neighbor_discovery.bidi_nb_size() == 0) {
            debug_->debug("Remove %d\n", radio_->id());
        } else {
            debug_->debug("Bidis: %d\n", neighbor_discovery.bidi_nb_size());
        }
         */
#endif
        //        if (radio_->id() == 0x14e7)
        //            cluster_radio_.present_neighbors();
        //debug_->debug("====%d=====", cluster_radio_.connections());


        //#ifndef VISUALIZER
        //if (clustering_algo_.status() != 2) {
        //    clustering_algo_.present_neighbors();
        //}
        //#endif

        //print periodically the neighborhood list
        /*   timer_->set_timer<ClusteringFronts,
                   &ClusteringFronts::start > (10000, this, 0);
         */
    }

#ifdef ENABLE_UART_CL

    void handle_uart_msg(uart_size_t len, Os::Uart::block_data_t *data) {
        //debug_->debug("Got a uart message %x", radio_->id());

        if (data[0] == 0x1) {
            //if an enable message
            if (data[1] == 0x1) {
                debug_->debug("ON");

                //neighbor_discovery.set_beacon_period(data[2]*500);
                //neighbor_discovery.set_timeout_perdio(data[2]*5 * 500);

                neighbor_discovery.enable();
                //        print periodically the neighborhood list
                timer_->set_timer<ClusteringFronts,
                        &ClusteringFronts::start > (40000, this, 0);

                clustering_algo_.enable(40);
                //timer_->set_timer<ClusteringFronts,
                //  &ClusteringFronts::start > (40000, this, 0);
                disabled_ = false;
            } else if (data[1] == 0x2) {
                debug_->debug("OFF");
                neighbor_discovery.disable();
                clustering_algo_.disable();
            } else if (data[1] == 0x3) {
/*                debug_->debug("Node %x received disable by rate from uart", radio_->id());
                if ((*rand_)() % 100 < FAILURES_PERCENTAGE) {
                    debug_->debug("Failure::%x::disabled", radio_->id());
                    neighbor_discovery.disable();
                    //        print periodically the neighborhood list
                    clustering_algo_.disable();
                    disabled_ = true;
                }
*/
            } else if (data[1] == 0x4) {
/*
                if (disabled_) {
                    debug_->debug("Failure::%x::enabled", radio_->id());

                    neighbor_discovery.enable();
                    //        print periodically the neighborhood list
                    clustering_algo_.enable(0);
                }
*/
            } else if (data[1] == 0x5) {
                int maxhops = data[2];
                debug_->debug("ChangeK;%x;%d", radio_->id(), maxhops);
                clustering_algo_.set_maxhops(maxhops);
            }
        }
    }
#endif

private:
    nb_t neighbor_discovery;

    Os::Position *position_;
    bool clustering_enabled_;

    bool head_dropped_;
    uint16_t period;
    int counter;

    VRadio virtual_radio_;


    // clustering algorithm modules
    CHD_t CHD_;
    JD_t JD_;
    IT_t IT_;
    // clustering algorithm core component
    clustering_algo_t clustering_algo_;
    bool disabled_;

    Os::TxRadio::self_pointer_t radio_;
    Os::Timer::self_pointer_t timer_;
    Os::Debug::self_pointer_t debug_;
    Os::Clock::self_pointer_t clock_;
#ifdef ENABLE_UART_CL
    Os::Uart::self_pointer_t uart_;
#endif
    Os::Rand::self_pointer_t rand_;
};
// --------------------------------------------------------------------------
wiselib::WiselibApplication<Os, ClusteringFronts> example_app;
// --------------------------------------------------------------------------

void application_main(Os::AppMainParameter& value) {
    example_app.init(value);
}
